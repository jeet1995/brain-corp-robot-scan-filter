Goal: To design filters which reduce noise of data generated by a LIDAR sensor attached to a robot.
--
Name : Abhijeet Mohanty
--
### Overview
* In this take home assignment, I implement two kinds of filters - `RangeFilter` and `TemporalMedianFilter`.
* The scan result to be generated by a robot are randomly generated.

### Development environment
* **OS :** MacOS Mojave
* **IDE :** IntelliJ IDEA 2018.1
* **Language used :** Python 2.7
* **Libraries used :** `numpy`, `argparse`, `unittest`, `random`

### Running the application
* Added permission to execute `run.sh` by executing `chmod u + x run.sh`
* Run the bash script by executing the command `./run.sh`
* Please enter *integral* values when prompted by the program to enter value on the standard input.


### Classes used in the application
* The `Robot` class :
    * This class generates a matrix with random values.
    * These values fall within the range of `[0.03, 50]`.
    * The size and no. of samples are 
    taken as user inputs which are in turn taken as command line arguments.
* The `RangeFilter` and `TemporalMedianFilter` classes :
    * An instance of the `RangeFilter` class is created with some user defined
    range.
    * Then the randomized matrix generated by an instance of `Robot` is passed to the `filter` method
    defined on `RangeFilter`.
    * An instance of the `TemporalMedianFilter` class is created with the `temporal_scan_size`. 
    * The `temporal_scan_size` is basically the no. of previous values to be considered in order to determine the 
    median.

### Algorithm
* Range based filtering
    * For range filtering, if the value in the input matrix 
      happens to be greater than the upper limit of the range, then the value is updated to the upper limit.
    * Analogously, if the value in the input matrix happens to be lower than the lower limit of the range, then the va;ue is updated to
      store the lower limit of the range.
* Temporal median filtering
    * The transpose of the input matrix is taken.
    * Once the transpose is taken, each row is iterated.
    * Two cases arise :
        * If the row index is lesser than the `temporal_scan_size`
            * Take the array starting from index `0` to index `i` for a given column j
            * Find the median of the array for all such columns `j`
        * Else
            * Take the array starting from index `i - temporal_scan_size`  to index `i` for a given column `j`
            * Find the median of the array for all such columns `j`
       

### Results

### Future improvements and ideas

